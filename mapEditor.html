<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Map Editor – JSON (Ground/Details/Details2/Ceiling/Ceiling2/Scripts)</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161922;
      --panel-2: #1b2030;
      --text: #e7eaf1;
      --muted: #9aa3b2;
      --accent: #6ea8fe;
      --danger: #ff6b6b;
      --grid: #2a3040;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: linear-gradient(180deg, #0f1115, #0f1115 200px, #0c0f14);
      color: var(--text);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-columns: 280px 1fr;
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "sidebar toolbar"
        "sidebar main";
      gap: 10px;
      padding: 10px;
    }
    header#toolbar {
      grid-area: toolbar;
      background: var(--panel);
      border: 1px solid #222838;
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      gap: 8px;
      align-items: center;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
    }
    #sidebar {
      grid-area: sidebar;
      display: flex;
      flex-direction: column;
      background: var(--panel);
      border: 1px solid #222838;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
    }
    #sidebar h3 {
      margin: 0;
      padding: 10px 12px;
      background: var(--panel-2);
      border-bottom: 1px solid #21263a;
      font-size: 13px;
      letter-spacing: .4px;
      text-transform: uppercase;
      color: #c9d0e3;
    }
    .ctrl {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #131722;
      border: 1px solid #242a3e;
      border-radius: 8px;
      padding: 6px 8px;
    }
    .ctrl label { color: var(--muted); font-size: 12px; }
    select, input[type="text"], input[type="number"], input[type="file"], textarea, button {
      background: #0f1320;
      color: var(--text);
      border: 1px solid #26314c;
      border-radius: 8px;
      padding: 6px 8px;
      outline: none;
    }
    textarea { resize: vertical; }
    select:focus, input:focus, textarea:focus, button:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(110,168,254,.2); }
    button { cursor: pointer; }
    button.primary { background: linear-gradient(180deg, #2a5fff, #2749e9); border-color: #3c5bff; }
    button.ghost { background: #111524; }
    button.danger { background: #2b1212; border-color: #4b1d1d; color: #ffc7c7; }

    #pickerPanel { padding: 10px; display: grid; gap: 8px; }
    #pickerScroll { overflow-y: auto; height: calc(100vh - 260px); border: 1px dashed #2a2f45; border-radius: 10px; padding: 8px; background: #0f1320; }
    #pickerCanvas { display: block; image-rendering: pixelated; }
    #pickedTilePreview { display: grid; grid-template-columns: auto 1fr; gap: 6px; align-items: center; }
    #pickedTileCanvas { image-rendering: pixelated; border:1px solid #2a2f45; border-radius: 6px; background:#0b0f18; }

    main#main { grid-area: main; background: var(--panel); border: 1px solid #222838; border-radius: 12px; padding: 10px; display: grid; grid-template-rows: 1fr auto; gap: 8px; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    #canvasWrap { overflow: auto; background: repeating-conic-gradient(from 45deg, #0d111a 0% 25%, #0a0d14 0% 50%) 50% / 32px 32px; border: 1px dashed #2a2f45; border-radius: 10px; padding: 8px; }
    #mapCanvas { display: block; image-rendering: pixelated; background: #0b0f18; border: 1px solid #26314c; border-radius: 8px; }
    #statusBar { display: flex; flex-wrap: wrap; justify-content: space-between; gap: 12px; padding: 6px 8px; background: #101525; border: 1px solid #212942; border-radius: 8px; color: #c6ccdd; font-size: 12px; }

    .hint { color: var(--muted); font-size: 12px; }
    .mini { font-size: 12px; color: #c8d0e5; }
    .flex { display: flex; gap: 8px; align-items: center; }
    .grid { display: grid; gap: 8px; }
    .sep { height: 1px; background: #23293b; margin: 6px 0; }
  </style>
</head>
<body>
  <!-- Sidebar / Tileset picker -->
  <aside id="sidebar">
    <h3>Tileset &amp; Picker</h3>
    <div id="pickerPanel">
      <div class="ctrl">
        <label for="tilesetSelect">Tileset</label>
        <select id="tilesetSelect" title="Wybierz PNG tilesetu"></select>
      </div>
      <div class="ctrl">
        <label for="tileSize">Tile</label>
        <input type="number" id="tileSize" min="4" max="128" step="1" value="32" style="width:72px" />
        <span class="mini">px</span>
      </div>
      <div id="pickedTilePreview" class="ctrl">
        <canvas id="pickedTileCanvas" width="64" height="64"></canvas>
        <div class="grid" style="gap:2px">
          <div class="mini">Akt. kafel: <span id="pickedLabel">(0,0)</span></div>
          <div class="mini">Typ (B): <span id="pickedTypeLabel">ground (0)</span></div>
          <div class="mini">Flagi (A): <span id="pickedFlagsLabel">0b0000</span></div>
        </div>
      </div>
      <div id="pickerScroll">
        <canvas id="pickerCanvas"></canvas>
      </div>
      <div class="hint">LPM: rysuj, PPM: usuń. ALT: pipeta. Warstwa <b>Scripts</b>: LPM dodaje/edytuje obiekt, PPM usuwa obiekt.</div>
    </div>
  </aside>

  <!-- Toolbar -->
  <header id="toolbar">
    <div class="ctrl" style="grid-column: span 3;">
      <label for="mapName">Mapa</label>
      <input id="mapName" type="text" placeholder="mapa_01" value="mapa_01" />
    </div>

    <div class="ctrl" style="grid-column: span 5;">
      <label>Warstwa</label>
      <label class="flex"><input type="radio" name="layer" value="ground" checked> Ground</label>
      <label class="flex"><input type="radio" name="layer" value="details"> Details</label>
      <label class="flex"><input type="radio" name="layer" value="details2"> Details2</label>
      <label class="flex"><input type="radio" name="layer" value="ceiling"> Ceiling</label>
      <label class="flex"><input type="radio" name="layer" value="ceiling2"> Ceiling2</label>
      <label class="flex"><input type="radio" name="layer" value="scripts"> Scripts</label>
    </div>

    <div class="ctrl" style="grid-column: span 2;">
      <label class="flex"><input type="checkbox" id="ghostOther" checked> Podgląd pozostałych</label>
      <label class="flex"><input type="checkbox" id="showGrid" checked> Siatka</label>
    </div>

    <div class="ctrl" style="grid-column: span 3;">
      <label for="typeSelect">Typ (B)</label>
      <select id="typeSelect"></select>
      <span class="mini">Ceiling* wymusza B=0</span>
    </div>

    <div class="ctrl" style="grid-column: span 3;">
      <label>Flagi (A)</label>
      <label class="flex"><input type="checkbox" id="flagFlipX"> FlipX</label>
      <label class="flex"><input type="checkbox" id="flagFlipY"> FlipY</label>
      <label class="flex"><input type="checkbox" id="flagRot90"> Rot90°</label>
    </div>

    <div class="ctrl" style="grid-column: span 3;">
      <label for="mapW">W</label>
      <input id="mapW" type="number" value="32" min="1" max="1024" style="width:72px" />
      <label for="mapH">H</label>
      <input id="mapH" type="number" value="18" min="1" max="1024" style="width:72px" />
      <button id="applySize" class="ghost">Zastosuj wymiary</button>
    </div>

    <div class="ctrl" style="grid-column: span 2;">
      <label for="zoomRange">Zoom</label>
      <input id="zoomRange" type="range" min="1" max="5" step="1" value="1" />
      <span id="zoomLabel" class="mini">x1</span>
    </div>

    <div class="ctrl" style="grid-column: span 4;">
      <button id="saveJsonBtn" class="primary">SAVE JSON</button>
      <input id="loadJsonInput" type="file" accept="application/json" />
      <button id="clearLayerBtn" class="danger">Wyczyść warstwę</button>
    </div>

    <!-- Script tools (visible only on Scripts layer) -->
    <div id="scriptTools" class="ctrl" style="grid-column: 1 / -1; display:none;">
      <strong>Scripts:</strong>
      <label for="scriptKind">Kind</label>
      <select id="scriptKind">
        <option value="teleport">teleport</option>
        <option value="npc">npc</option>
        <option value="trigger">trigger</option>
        <option value="note">note</option>
      </select>
      <label for="scriptProps">Props (JSON)</label>
      <input id="scriptProps" type="text" placeholder='{"to":"map_b","x":2,"y":3}' style="min-width:320px" />
      <span class="hint">LPM: postaw/edytuj obiekt na kratce. ALT+klik: pipeta obiektu.</span>
    </div>
  </header>

  <!-- Main / Canvas -->
  <main id="main">
    <div id="canvasWrap">
      <canvas id="mapCanvas" width="512" height="512"></canvas>
    </div>
    <div id="statusBar">
      <div>Pos: <span id="posLabel">-,-</span> | Tile: <span id="tileLabel">-,-</span></div>
      <div>Warstwa: <span id="layerLabel">ground</span> | Tileset: <span id="tilesetName">(brak)</span></div>
      <div>MB1: rysuj | MB2: usuń | <span class="hint">Alt: pipeta</span></div>
    </div>
  </main>

  <script>
    // ===== Konfiguracje =====
    const TILESETS = [
      './assets/sprites/tileset.png'
    ];

    const TILE_TYPES = [
      { name: 'ground', value: 0 },
      { name: 'wall',   value: 1 },
      { name: 'ice',    value: 2 },
      { name: 'ledge',  value: 3 },
      { name: 'water',  value: 4 },
      { name: 'lava',   value: 5 },
      { name: 'decor',  value: 6 }
    ];

    // Flagi A (dolny nibble): bit0 flipX, bit1 flipY, bit2 rot90, bit3 rezerw.
    const FLAG = { FLIP_X:1, FLIP_Y:2, ROT_90:4 };

    // Warstwy (kolejność rysowania)
    const VISUAL_LAYERS = ['ground','details','details2','ceiling','ceiling2'];
    const ALL_LAYERS = [...VISUAL_LAYERS, 'scripts'];

    // ===== Stan =====
    const state = {
      mapW: 32,
      mapH: 18,
      tileSize: 32,
      zoom: 1,
      activeLayer: 'ground',
      ghostOther: true,
      showGrid: true,
      brush: { tileX: 0, tileY: 0, typeB: 0, flagsA: 0 },
      scriptBrush: { kind: 'teleport', props: {} },
      layers: {
        ground: null, details: null, details2: null, ceiling: null, ceiling2: null
      },
      scripts: [], // {kind, x, y, props}
      tileset: { url: TILESETS[0], img: null, cols: 0, rows: 0 },
      mouseDown: false, mouseButton: 0
    };

    // ===== DOM =====
    const mapCanvas = document.getElementById('mapCanvas');
    const mapCtx = mapCanvas.getContext('2d');
    const pickerCanvas = document.getElementById('pickerCanvas');
    const pickerCtx = pickerCanvas.getContext('2d');
    const pickedCanvas = document.getElementById('pickedTileCanvas');
    const pickedCtx = pickedCanvas.getContext('2d');

    const tilesetSelect = document.getElementById('tilesetSelect');
    const tileSizeInput = document.getElementById('tileSize');
    const typeSelect = document.getElementById('typeSelect');
    const flagFlipX = document.getElementById('flagFlipX');
    const flagFlipY = document.getElementById('flagFlipY');
    const flagRot90 = document.getElementById('flagRot90');

    const mapWInput = document.getElementById('mapW');
    const mapHInput = document.getElementById('mapH');
    const applySizeBtn = document.getElementById('applySize');

    const zoomRange = document.getElementById('zoomRange');
    const zoomLabel = document.getElementById('zoomLabel');
    const ghostOther = document.getElementById('ghostOther');
    const showGrid = document.getElementById('showGrid');

    const saveJsonBtn = document.getElementById('saveJsonBtn');
    const loadJsonInput = document.getElementById('loadJsonInput');
    const clearLayerBtn = document.getElementById('clearLayerBtn');
    const mapNameInput = document.getElementById('mapName');

    const posLabel = document.getElementById('posLabel');
    const tileLabel = document.getElementById('tileLabel');
    const layerLabel = document.getElementById('layerLabel');
    const tilesetName = document.getElementById('tilesetName');
    const pickedLabel = document.getElementById('pickedLabel');
    const pickedTypeLabel = document.getElementById('pickedTypeLabel');
    const pickedFlagsLabel = document.getElementById('pickedFlagsLabel');

    const scriptTools = document.getElementById('scriptTools');
    const scriptKind = document.getElementById('scriptKind');
    const scriptProps = document.getElementById('scriptProps');

    // Warstwa wyboru
    document.querySelectorAll('input[name="layer"]').forEach(r => {
      r.addEventListener('change', () => {
        state.activeLayer = r.value;
        layerLabel.textContent = state.activeLayer;
        const ceilingMode = (state.activeLayer === 'ceiling' || state.activeLayer === 'ceiling2');
        typeSelect.disabled = ceilingMode || state.activeLayer==='scripts';
        flagFlipX.disabled = state.activeLayer==='scripts';
        flagFlipY.disabled = state.activeLayer==='scripts';
        flagRot90.disabled = state.activeLayer==='scripts';
        // script tools toggle
        scriptTools.style.display = state.activeLayer==='scripts' ? '' : 'none';
        render();
      });
    });

    ghostOther.addEventListener('change', () => { state.ghostOther = ghostOther.checked; render(); });
    showGrid.addEventListener('change', () => { state.showGrid = showGrid.checked; render(); });

    function initTilesetSelect() {
      tilesetSelect.innerHTML = '';
      TILESETS.forEach((url, i) => {
        const opt = document.createElement('option');
        opt.value = url; opt.textContent = url; if (i===0) opt.selected = true;
        tilesetSelect.appendChild(opt);
      });
      tilesetSelect.addEventListener('change', () => loadTileset(tilesetSelect.value));
    }

    function initTypeSelect() {
      typeSelect.innerHTML = '';
      TILE_TYPES.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.value; opt.textContent = `${t.name} (${t.value})`;
        typeSelect.appendChild(opt);
      });
      typeSelect.value = 0;
      typeSelect.addEventListener('change', () => {
        state.brush.typeB = parseInt(typeSelect.value,10) || 0;
        updatePickedLabels();
      });
    }

    [flagFlipX, flagFlipY, flagRot90].forEach(chk => chk.addEventListener('change', () => {
      state.brush.flagsA = (flagFlipX.checked?FLAG.FLIP_X:0) | (flagFlipY.checked?FLAG.FLIP_Y:0) | (flagRot90.checked?FLAG.ROT_90:0);
      updatePickedLabels();
      renderPickedPreview();
    }));

    tileSizeInput.addEventListener('change', () => {
      const v = clamp(parseInt(tileSizeInput.value,10)||32, 4, 128);
      state.tileSize = v; tileSizeInput.value = v;
      computeTilesetGrid();
      drawPicker();
      resizeMapCanvas();
      render();
      renderPickedPreview();
    });

    mapWInput.addEventListener('change', syncSizeInputs);
    mapHInput.addEventListener('change', syncSizeInputs);
    function syncSizeInputs(){
      mapWInput.value = clamp(parseInt(mapWInput.value,10)||state.mapW,1, 4096);
      mapHInput.value = clamp(parseInt(mapHInput.value,10)||state.mapH,1, 4096);
    }

    applySizeBtn.addEventListener('click', () => {
      const W = parseInt(mapWInput.value,10);
      const H = parseInt(mapHInput.value,10);
      resizeMap(W,H,true);
      render();
    });

    zoomRange.addEventListener('input', () => {
      state.zoom = parseInt(zoomRange.value,10) || 1;
      zoomLabel.textContent = `x${state.zoom}`;
      resizeMapCanvas();
      render();
    });

    scriptKind.addEventListener('change', () => { state.scriptBrush.kind = scriptKind.value; });
    scriptProps.addEventListener('change', () => { const p = tryParseJSON(scriptProps.value); if (p!==undefined) state.scriptBrush.props = p; });

    // ===== Tileset =====
    async function loadTileset(url){
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = url;
      await img.decode();
      state.tileset.img = img;
      state.tileset.url = url;
      tilesetName.textContent = url.split('/').pop();
      computeTilesetGrid();
      drawPicker();
      renderPickedPreview();
      render();
    }

    function computeTilesetGrid(){
      const { img } = state.tileset; if (!img) return;
      const ts = state.tileSize;
      state.tileset.cols = Math.floor(img.width / ts);
      state.tileset.rows = Math.floor(img.height / ts);
      pickerCanvas.width = state.tileset.cols * ts;
      pickerCanvas.height = state.tileset.rows * ts;
    }

    function drawPicker(){
      const { img } = state.tileset; if (!img) return;
      const ts = state.tileSize;
      pickerCtx.clearRect(0,0,pickerCanvas.width,pickerCanvas.height);
      pickerCtx.imageSmoothingEnabled = false;
      pickerCtx.drawImage(img, 0,0);
      // siatka
      pickerCtx.strokeStyle = '#223'; pickerCtx.lineWidth = 1;
      for (let x=0; x<=pickerCanvas.width; x+=ts){ pickerCtx.beginPath(); pickerCtx.moveTo(x+.5,0); pickerCtx.lineTo(x+.5,pickerCanvas.height); pickerCtx.stroke(); }
      for (let y=0; y<=pickerCanvas.height; y+=ts){ pickerCtx.beginPath(); pickerCtx.moveTo(0,y+.5); pickerCtx.lineTo(pickerCanvas.width,y+.5); pickerCtx.stroke(); }
      // highlight
      pickerCtx.strokeStyle = '#6ea8fe'; pickerCtx.lineWidth = 2;
      pickerCtx.strokeRect(state.brush.tileX*ts+1, state.brush.tileY*ts+1, ts-2, ts-2);
    }

    pickerCanvas.addEventListener('mousedown', (e) => {
      const p = pointerInCanvas(e, pickerCanvas);
      const ts = state.tileSize;
      const tileX = Math.floor(p.x / ts);
      const tileY = Math.floor(p.y / ts);
      state.brush.tileX = clamp(tileX,0,state.tileset.cols-1);
      state.brush.tileY = clamp(tileY,0,state.tileset.rows-1);
      drawPicker();
      renderPickedPreview();
      updatePickedLabels();
      e.preventDefault();
    });

    function renderPickedPreview(){
      const {img} = state.tileset; if (!img) return;
      const ts = state.tileSize;
      pickedCanvas.width = ts*2; pickedCanvas.height = ts*2;
      pickedCtx.imageSmoothingEnabled = false;
      pickedCtx.clearRect(0,0,pickedCanvas.width,pickedCanvas.height);
      const sx = state.brush.tileX * ts; const sy = state.brush.tileY * ts;
      pickedCtx.save();
      pickedCtx.translate(pickedCanvas.width/2, pickedCanvas.height/2);
      applyBrushTransform(pickedCtx);
      pickedCtx.drawImage(img, sx, sy, ts, ts, -ts, -ts, ts*2, ts*2);
      pickedCtx.restore();
    }

    function updatePickedLabels(){
      pickedLabel.textContent = `(${state.brush.tileX},${state.brush.tileY})`;
      const t = TILE_TYPES.find(t => t.value===state.brush.typeB) || {name:'custom', value: state.brush.typeB};
      pickedTypeLabel.textContent = `${t.name} (${t.value})`;
      pickedFlagsLabel.textContent = '0b' + (state.brush.flagsA & 0x0f).toString(2).padStart(4,'0');
    }

    // ===== Dane mapy =====
    function allocateLayerGrid(W,H){
      const g = new Array(H);
      for (let y=0; y<H; y++){ g[y] = new Array(W).fill(null); }
      return g;
    }

    function resizeMap(W,H, preserve=false){
      const oldW = state.mapW, oldH = state.mapH;
      const oldLayers = preserve ? { ...state.layers } : null;
      const oldScripts = preserve ? [...state.scripts] : null;
      state.mapW = W; state.mapH = H;
      mapWInput.value = W; mapHInput.value = H;
      // realloc warstw
      for (const L of VISUAL_LAYERS){ state.layers[L] = allocateLayerGrid(W,H); }
      // przenieś zawartość
      if (preserve && oldLayers){
        const minW = Math.min(oldW, W), minH = Math.min(oldH, H);
        for (const L of VISUAL_LAYERS){
          const src = oldLayers[L]; if (!src) continue;
          for (let y=0;y<minH;y++) for (let x=0;x<minW;x++) state.layers[L][y][x] = src[y][x];
        }
        state.scripts = oldScripts.filter(s => s.x < W && s.y < H);
      } else {
        state.scripts = [];
      }
      resizeMapCanvas();
    }

    function resizeMapCanvas(){
      const scale = state.zoom;
      const cssW = state.mapW * state.tileSize * scale;
      const cssH = state.mapH * state.tileSize * scale;
      mapCanvas.width = cssW; mapCanvas.height = cssH;
      mapCtx.imageSmoothingEnabled = false;
    }

    function setTile(layer, x, y, tile){
      if (x<0||y<0||x>=state.mapW||y>=state.mapH) return;
      state.layers[layer][y][x] = tile; // tile = {r,g,b,a} lub null
    }

    function getTile(layer, x, y){
      if (x<0||y<0||x>=state.mapW||y>=state.mapH) return null;
      return state.layers[layer][y][x];
    }

    function isCeilingLayer(name){ return name==='ceiling' || name==='ceiling2'; }

    // ===== Render =====
    function render(){
      const ts = state.tileSize; const z = state.zoom; const {img} = state.tileset;
      mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
      const drawLayer = (name, alpha) => {
        const grid = state.layers[name]; if (!grid || !img) return;
        mapCtx.save(); mapCtx.globalAlpha = alpha; mapCtx.scale(z,z);
        for (let y=0; y<state.mapH; y++){
          for (let x=0; x<state.mapW; x++){
            const t = grid[y][x]; if (!t) continue;
            drawTileAt(x,y, t.r, t.g, t.b, t.a);
          }
        }
        mapCtx.restore();
      };

      for (const L of VISUAL_LAYERS){
        const alpha = (state.activeLayer===L) ? 1.0 : (state.ghostOther?0.35:0.15);
        drawLayer(L, alpha);
      }

      // Scripts overlay (ikony)
      drawScriptsOverlay();

      if (state.showGrid){
        mapCtx.save(); mapCtx.scale(z,z);
        mapCtx.strokeStyle = 'rgba(255,255,255,0.06)';
        for (let x=0; x<=state.mapW*ts; x+=ts){ mapCtx.beginPath(); mapCtx.moveTo(x+.5,0); mapCtx.lineTo(x+.5,state.mapH*ts); mapCtx.stroke(); }
        for (let y=0; y<=state.mapH*ts; y+=ts){ mapCtx.beginPath(); mapCtx.moveTo(0,y+.5); mapCtx.lineTo(state.mapW*ts,y+.5); mapCtx.stroke(); }
        mapCtx.restore();
      }
    }

    function drawTileAt(tx,ty, r,g, b, a){
      const { img } = state.tileset; if (!img) return;
      const ts = state.tileSize; const z = state.zoom;
      const sx = r * ts; const sy = g * ts;
      const dx = tx * ts * z; const dy = ty * ts * z;
      mapCtx.save();
      mapCtx.translate(dx + (ts*z)/2, dy + (ts*z)/2);
      applyFlagsTransform(mapCtx, a);
      mapCtx.drawImage(img, sx, sy, ts, ts, -(ts*z)/2, -(ts*z)/2, ts*z, ts*z);
      mapCtx.restore();
    }

    function drawScriptsOverlay(){
      const ts = state.tileSize; const z = state.zoom;
      mapCtx.save(); mapCtx.scale(z,z);
      for (const s of state.scripts){
        const x = s.x*ts, y = s.y*ts;
        mapCtx.fillStyle = 'rgba(255,215,0,0.85)';
        mapCtx.strokeStyle = 'rgba(0,0,0,0.8)';
        mapCtx.lineWidth = 2;
        mapCtx.beginPath();
        mapCtx.rect(x+2, y+2, ts-4, ts-4);
        mapCtx.fill(); mapCtx.stroke();
        mapCtx.fillStyle = '#000';
        mapCtx.font = `${Math.floor(ts*0.5)}px monospace`;
        mapCtx.textAlign = 'center'; mapCtx.textBaseline = 'middle';
        const label = (s.kind||'').slice(0,1).toUpperCase();
        mapCtx.fillText(label, x+ts/2, y+ts/2);
      }
      mapCtx.restore();
    }

    function applyBrushTransform(ctx){
      const f = state.brush.flagsA & 0x0f;
      if (f & FLAG.ROT_90) ctx.rotate(Math.PI/2);
      const sx = (f & FLAG.FLIP_X) ? -1 : 1;
      const sy = (f & FLAG.FLIP_Y) ? -1 : 1;
      ctx.scale(sx, sy);
    }

    function applyFlagsTransform(ctx, a){
      const f = a & 0x0f;
      if (f & FLAG.ROT_90) ctx.rotate(Math.PI/2);
      const sx = (f & FLAG.FLIP_X) ? -1 : 1;
      const sy = (f & FLAG.FLIP_Y) ? -1 : 1;
      ctx.scale(sx, sy);
    }

    // ===== Interakcja mapy =====
    mapCanvas.addEventListener('contextmenu', e => e.preventDefault());

    mapCanvas.addEventListener('mousedown', (e) => {
      state.mouseDown = true; state.mouseButton = e.button; paintFromEvent(e);
    });
    mapCanvas.addEventListener('mousemove', (e) => {
      updateStatusFromEvent(e);
      if (state.mouseDown) paintFromEvent(e);
    });
    window.addEventListener('mouseup', () => { state.mouseDown = false; });

    function updateStatusFromEvent(e){
      const p = pointerInCanvas(e, mapCanvas);
      posLabel.textContent = `${Math.floor(p.x)},${Math.floor(p.y)}`;
      const tsz = state.tileSize*state.zoom;
      const tx = clamp(Math.floor(p.x / tsz), 0, state.mapW-1);
      const ty = clamp(Math.floor(p.y / tsz), 0, state.mapH-1);
      tileLabel.textContent = `${tx},${ty}`;
    }

    function paintFromEvent(e){
      const altPick = e.altKey; // pipeta
      const tsz = state.tileSize * state.zoom;
      const p = pointerInCanvas(e, mapCanvas);
      const tx = clamp(Math.floor(p.x / tsz), 0, state.mapW-1);
      const ty = clamp(Math.floor(p.y / tsz), 0, state.mapH-1);

      if (state.activeLayer==='scripts'){
        if (altPick){ // pipeta obiektu
          const s = findScriptAt(tx,ty); if (s){
            scriptKind.value = s.kind; state.scriptBrush.kind = s.kind;
            scriptProps.value = JSON.stringify(s.props||{}); state.scriptBrush.props = s.props||{};
          }
          return;
        }
        if (state.mouseButton===2){ // usuń obiekt
          removeScriptAt(tx,ty); render(); return;
        } else {
          // dodaj/edytuj obiekt
          const props = tryParseJSON(scriptProps.value); if (props!==undefined) state.scriptBrush.props = props;
          upsertScriptAt(tx,ty, state.scriptBrush.kind, state.scriptBrush.props);
          render(); return;
        }
      }

      if (altPick){ // pipeta kafla z aktywnej warstwy
        const t = getTile(state.activeLayer, tx, ty);
        if (t){
          state.brush.tileX = t.r; state.brush.tileY = t.g; state.brush.typeB = t.b; state.brush.flagsA = t.a;
          typeSelect.value = String(state.brush.typeB);
          flagFlipX.checked = !!(t.a & FLAG.FLIP_X);
          flagFlipY.checked = !!(t.a & FLAG.FLIP_Y);
          flagRot90.checked = !!(t.a & FLAG.ROT_90);
          drawPicker(); renderPickedPreview(); updatePickedLabels();
        }
        return;
      }

      if (state.mouseButton === 2){ // PPM – gumka
        setTile(state.activeLayer, tx, ty, null);
      } else { // LPM – rysuj
        const r = state.brush.tileX & 255;
        const g = state.brush.tileY & 255;
        const b = isCeilingLayer(state.activeLayer) ? 0 : (state.brush.typeB & 255);
        const a = state.brush.flagsA & 255;
        setTile(state.activeLayer, tx, ty, {r,g,b,a});
      }
      render();
    }

    function findScriptAt(x,y){ return state.scripts.find(s => s.x===x && s.y===y); }
    function removeScriptAt(x,y){ state.scripts = state.scripts.filter(s => !(s.x===x && s.y===y)); }
    function upsertScriptAt(x,y, kind, props){
      const ex = findScriptAt(x,y);
      if (ex){ ex.kind = kind; ex.props = deepClone(props||{}); }
      else state.scripts.push({ kind, x, y, props: deepClone(props||{}) });
    }

    function pointerInCanvas(evt, canvas){
      const rect = canvas.getBoundingClientRect();
      return { x: (evt.clientX - rect.left), y: (evt.clientY - rect.top) };
    }

    // ===== SAVE / LOAD JSON =====
    function saveJSON(){
      const data = {
        name: (mapNameInput.value||'mapa').replace(/\s+/g,'_'),
        tileset: state.tileset.url,
        tileSize: state.tileSize,
        width: state.mapW, height: state.mapH,
        layers: {},
        scripts: state.scripts
      };
      for (const L of VISUAL_LAYERS){ data.layers[L] = state.layers[L]; }
      const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${data.name}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    }

    async function loadJSON(file){
      if (!file) return;
      const text = await file.text();
      let obj; try { obj = JSON.parse(text); } catch(e){ alert('Błędny JSON'); return; }
      // minimalna walidacja
      const W = obj.width|0, H = obj.height|0; if (!W||!H){ alert('Brak width/height w JSON'); return; }
      state.tileSize = obj.tileSize|0 || state.tileSize; tileSizeInput.value = state.tileSize;
      if (obj.tileset){ await loadTileset(obj.tileset); tilesetSelect.value = obj.tileset; }
      resizeMap(W,H,false);
      for (const L of VISUAL_LAYERS){
        if (obj.layers && obj.layers[L]){
          // skopiuj w granicach mapy
          for (let y=0;y<Math.min(H, obj.layers[L].length);y++){
            for (let x=0;x<Math.min(W, obj.layers[L][y].length);x++){
              const t = obj.layers[L][y][x];
              state.layers[L][y][x] = t && typeof t.r==='number' ? {r:t.r|0, g:t.g|0, b:t.b|0, a:t.a|0} : null;
            }
          }
        }
      }
      state.scripts = Array.isArray(obj.scripts) ? obj.scripts.map(s=>({kind:String(s.kind||'note'), x:s.x|0, y:s.y|0, props: s.props||{}})) : [];
      mapNameInput.value = (obj.name||'mapa');
      render();
    }

    saveJsonBtn.addEventListener('click', saveJSON);
    loadJsonInput.addEventListener('change', (e)=> loadJSON(e.target.files[0]));
    clearLayerBtn.addEventListener('click', () => {
      if (state.activeLayer==='scripts') { state.scripts = []; }
      else {
        const L = state.activeLayer; for (let y=0;y<state.mapH;y++) for (let x=0;x<state.mapW;x++) state.layers[L][y][x]=null;
      }
      render();
    });

    // ===== Utils =====
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
    function tryParseJSON(s){ if (!s || !s.trim()) return {}; try { return JSON.parse(s); } catch(e){ alert('Props: błędny JSON'); return undefined; } }

    // ===== Start =====
    function boot(){
      initTilesetSelect();
      initTypeSelect();
      resizeMap(state.mapW, state.mapH);
      resizeMapCanvas();
      updatePickedLabels();
      loadTileset(state.tileset.url);
      zoomLabel.textContent = `x${state.zoom}`;
      scriptKind.value = state.scriptBrush.kind;
    }
    boot();
  </script>
</body>
</html>
